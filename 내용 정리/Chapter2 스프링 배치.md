# Chapter2 스프링 배치

## Step

개념점으로 스프링 배치 잡은 상태 기계(State Machine)이 지나지 않는다.  스프링 배치에서 가장 일반적으로 상태를 보여주는 단위가 스텝이다.

- 각 스텝은 잡을 구성하는 독립된 작업의 단위이다.
- 스텝은 태스크릿(tasklet)과 청크(chunk) 기반 유형이 있다.

</br >

### 테스크릿(tasklet)

- 비교적으로 청크 기반보다 테스크릿 기반 스텝의 구조가 더 간단하다.
- 테스크릿 기반 스텝을 사용하려면 Tasklet을 구현하면 된다. 스텝이 중지될 떄까지 exeute 메서드가 계속 반복해서 수행된다.
  - execute 메서드를 호출할 때마다 독립적인 트랜잭션이 얻어진다.
- 보통 초기화, 져장 프로시저 실행, 알림 전송 등과 같은 Job에서 일반적으로 사용된다.

</br >

### 청크(chunk)

- 각 청크 기반 스템은 ItemReader, ItemProcessor, ItemWriter라는 3개의 주요 부분으로 구성될 수 있다.
  - 참고로 ItemProcessor는 필수가 아니기 때문에 ItemReader와 ItemWriter만으로 구성해 스텝을 실행할 수 있따.
  - 이러한 스텝은 데이터 마이그레이션 잡이 일반적으로 사용된다.

</br >

## 스프링 잡 구조화 방법의 장점

스프링 잡 구조화 방법이 가진 장점 중 하나는 각 스텝이 서로 독립적으로 처리될 수 있도록 했다는 것

### 유연성

- 스프링 배치는 개발자가 재사용이 가능하게 구성할 수 있도록 여러 빌드 클래스를 제공
- 즉, 복잡한 작업 플로우를 구성할 때 유연하게 사용 가능

### 유지 보수성

- 각각의 스텝은 독립적이므로 각 스텝의 단위 테스트, 변경 등을 할 수 있다.
- 분리된 스텝은 여러 잡에서 재사용할 수 있다.

### 확장성

- 스텝의 병렬처리가 가능하다.
- 즉, 하나의 스텝 내에서 처리할 일을 여러 스레드로 나눌 수 있다.
- 이를 통해 코드의 변경을 최소화하면서 업무의 확장성에 대한 요구 사항을 충족할 수 있다.

### 신뢰성

- 예외 발생 시 해당 아이템의 처리를 재시도하거나 건너뛰기하는 등의 동작을 수행할 수 있다.

</br >

## 잡 실행

잡이 실행될 때 스프링 배치의 많은 컴포넌트는 상호 작용을 한다. 아래 그림은 배치 컴포넌트 관의 관계를 나타낸다.

![image](https://user-images.githubusercontent.com/43977617/135716383-57c8f830-8cae-425c-b384-328a66e46f06.png)

</br >

### JobRepository

- JobRepository는 스프링 배치 아키텍처 내에서 공유되는 주요 컴포넌트이다.
- 해당 컴포넌트는 다양한 배치 수행과 관련된 수치 데이터(시작, 종료 시간, 상태 등)와 잡의 상태를 유지 관리한다.
- 주로 RDB를 사용한다.

</br >

### JobLauncher

- 잡을 실행하는 역할 (Job.execute)
- 잡의 재실행 가능 여부 검증
- 잡의 실행 방법 (현재 스레드에서 수행할지 스레드 풀을 통해 실행할지)
- 파라미터 유효성 검증 처리
- 스프링 부터 환경이라면 스프링 부트가 즉시 잡을 시작하는 기능을 제공하므로 JobLauncher를 직접 다룰 필요 없다.

</br >

## Job 계층

Job은 Step 인스턴스를 위한 컨테이너다.

Job의 흐름에서 논리적으로 함께 속하는 여러 단계를 결합하고 재시작 가능성과 같은 모든 단계에 전역 속성을 구성할 수 있다.

Job의 구성에는 다음이 포함된다.

- Job의 간단한 이름
- Step의 정의 및 순서
- Job의 재시작 가능 여부

![image](https://user-images.githubusercontent.com/43977617/135717108-c59e8745-7e07-4ce0-8388-ede21d49b629.png)

</br >

### JobInstance

- 스프링 배치 잡의 논리적인 실행 개념을 나타낸다.
- JonInstance는 Job의 이름  + JobParameters로 유일하게 존재한다.
- Job이 실행할 때 이미 같은 조합으로 만들어진 인스턴스가 있으면 새로 생성되지 않을 수 있다.
  - 예로, 실행에 실패한 이후 다시 실행하면, 여전히 동일한 논리적 실행(파라미터 동일)이므로 새로운 인스턴스를 생성하지 않는다.

</br >

### JonExecution

- 스프링 배치 잡의 실제 실행을 의미한다.
- 잡을 실행할 때마다 새로운 JobExecution을 얻는다.
- 만약 execution이 성공적으로 완료되지 않았을 때 이에 해당하는 JonInstance 또한 완료된 것으로 간주되지 않는다.
  - 다만 동일한 JobParameters를 사용하여 다시 실행할 경우 새로운 JobExecution이 생성되고, JobInstance는 그대로다.

</br >

## 병렬화

스프링 배치는 다양한 병렬화 방법을 제공한다.

다중 스레드 스텝, 전체 스텝의 병렬 실행, 비동기 ItemProcessor/ItemWriter, 원격 청킹, 파티셔닝 다섯 가지 방법이 있다.

</br >

### 다중 스레드 스텝 (Multi-threaded Step)

- 스프링 배치에서 Job은 청크라는 블록 단위로 처리되도록 구성되며, 각 청크는 각자 독립적인 트랜잭션으로 처리된다.
- 특정 스탭 내 청크 처리를 병렬로 실행해 성능을 향상시킬 수 있다.

</br >

### 병렬 스텝 (Parallel Steps)

- 병렬 스텝은 말 그대로 스텝을 병렬로 실행하는 것이다.
- 스텝과 스텝이 서로 관련이 없다면 병렬로 처리할 수 있다.

</br >

### 비동기 ItemProcessor/ItemWriter

- Setup 내의 ItemProcessor에 병목현상이 발생할 수 있다. 이때 일부 스텝을 병렬화하는 기능이 유용할 수 있다.

</br >

위 세 가지 예제는 단일 JVM에서 실행된다. 그러므로 확장성 측면에 한계가 있다. 앞으로 알아볼 두 가지 병렬화 방식은 분산 처리를 사용한다.

### 원격 청킹 (Remote Chunking)

![image](https://user-images.githubusercontent.com/43977617/135719086-949e198a-01a7-4758-9c6b-c458623b2e24.png)

- 원격 청킹에서 스텝 처리는 여러 프로세스로 분할되어 일부 미들웨어를 통해 서로 통신한다.
- 이 방법은 마스터에서 데이터를 읽고(ItemReader) 원격 워커(ex: 레빗MQ)에서 처리한 다음 다시 마스터에게 전송한다.
  - 네트워크 사용량이 많아질 수 있다.

</br >

### 파티셔닝 (Partitioning)

![image](https://user-images.githubusercontent.com/43977617/135719093-7c45b8d1-1412-4660-a298-21ac28b533c8.png)

- 스프링 배치는 원격 파티셔닝 및 로컬 파티셔닝을 모두 지원한다.
- 원격 청킹과의 차이점은 원격 파티셔닝을 사용하면 마스터는 워커의 스텝 수집을 위한 컨트롤러 역할만 한다.
  - 이때, 각 워커의 스텝은 독립적으로 동작한다.
- 모든 워커가 각각 맡은 일을 완료하면 마스터 스텝이 완료된 것으로 간주된다.
- 원격 청킹 방식은 JobRepository가 분산된 작업의 상태를 알지 못하지만 파티셔닝은 JobRepository가 복제된 작업이 없고 모든 작업이 완료됐음을 보장하기 때문에 내구성 있는 지속적인 통신 필요없다.

</br >

