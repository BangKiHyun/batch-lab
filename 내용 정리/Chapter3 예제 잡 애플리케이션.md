# Chapter3 예제 잡 애플리케이션

## 스프랭 배치 중요 기능

### 다양한 입력 및 출력 방식

- 다양한 소스를 대상으로 데이터의 입/출력을 처리하는 잘 추상화된 입출력 기능
- 은행 거래명세서 잡은 일반적인 텍스트 파일 플랫 파일과 데이터베이스에서 입력을 받음. 또한 플랫 파일과 데이터베이스에서 출력
- 해당 Job에서 다양한 Reader 및 Writer를 사용

### 오류 처리

- 배치 처리를 유지보수 하면서 겪는 최악의 상황은 배치 처리 중 오류가 발생해서 해결하는 것
- 배치 처리는 로깅, 오류가 있는 레코드 건너뛰기, 로직 수행 중 오류 발생 시 해당 로직 재시도하기 등 다양한 처리를 할 수 있다.

### 확장성

- 배치 처리는 많은 양의 데이터를 처리할 수 있어야 한다.
- 수백만 명의 데이터를 처리할 수 있도록 배치 처리를 튜닝할 수 있다.

</br >

## 사용자 스토리

사용자 스토리는 요구 사항을 문서화하는 애자일 방법

### 사용자 스토리 구성 세 가지

- 제목(title)
  - 스토리의 내용과 관련된 단순하고 간결한 설명 (ex: 인쇄 파일을 생성한다)
  - GUI와 관련된 내용으로 한정되지 않음.
- 내러티브(narrative)
  - 스토리로 문서화하려는 상호작용을 사용자 관점에서 설명한 것
  - X 상황에서 Y가 무언가를 수행하고, 어떤 다른 일이 발생한다.
- 인수 기준(acceptance criteria)
  - 스토리 완료 여부를 판단하는 데 사용할 수 있는 테스트 가능한 요구 사항
  - 주관적인 요구 사항이 아닌 개발자 측면에서 '네, 아니오'로 말할 수 있는 객관적인 항목

### 사용자 스토리 예제

- 제목: 텔레비전 켜기
- 내러티브
  - 사용자는 텔레비전, 수신기, 케이블 박스를 끈 상태에서 범용 리모컨의 전원 버튼을 누를 수 있다.
  - 그러면 리모컨은 텔레비전, 수신기, 케이블 박스의 전원을 켜고 텔레비전 쇼를 보도록 구성한다.
- 인수 기준
  - 범용 리모컨에 전원 버튼이 있다.
  - 사용자가 전원 버튼을 누르면 다음과 같이 동작한다.
    1. 텔레비전 전원이 켜진다. 
    2. 수신기 전원이 켜진다.
    3. 케이블 박스 전원이 켜진다.
    4. TV는 비디오 1 입력으로 설정될 것이다.

</br >

## 은행 거래명세서 잡 요구 사항

배치 처리로 일반 텍스트 파일보다 좀 더 세부 정보가 포함된 인쇄용 파일을 생성할 것이다.

### 배치 처리가 수행하는 기능

1. 제공된 입력 파일을 기반으로 고객 정보 갱신하기
2. 데이터베이스에 저장된 모든 고객의 거래 정보 가져오기
3. 계좌 잔액으로 계좌 정보 갱신하기
4. 지난 한 달 동안의 은행 계좌 파일 인쇄하기

</br >

### 사용자 스토리 1

- 제목: 고객 정보 갱신하기
- 내러티브
  - 배치 처리로 고객 정보를 가져와 기존 고객 레코드를 갱신한다.
- 인수 기준
  - 배치 잡은 csv 기반의 고객 정보 갱신 파일을 읽는다.
  - 유형에 맞게 고객 레코드 갱신이 이뤄진다.
    1. 레코드 유형 1은 이름 변경을 나타낸다.
    2. 레코드 유형 2는 메일 주소 변경을 나타낸다.
    3. 레코드 유형 3은 연락처 정보 변경을 나타낸다.
  - 유효성 검증 오류가 있는 레코드는 추후 유효성 검증 및 재처리를 위해 오류 파일에 기록돼 있어야 한다.

</br >

### 사용자 스토리 2

- 제목: 거래 정보 가져오기
- 내러티브
  - XML 형식의 입력 파일로 제공된 새로운 모든 거래 정보를 배치 처리로 가져온다.
- 인수 기준
  - 처리 시 XML 파일로 작성된 거래 정보를 읽는다.
  - 각 거래 정보는 거래 테이블에 새 레코드로 생성된다.

</br >

### 사용자 스토리 3

- 제목: 계좌 테이블에 거래 정보 갱신하기
- 내러티브
  - 배치 처리로 계좌 테이블의 최신 잔액 정보를 갱신한다.
- 인수 기준
  - 계좌 테이블에는 잔액 필드가 있으며, 이 필드는 가장 최근에 가져온 모든 거래 정보를 사용해 갱신된다.

</br >

### 사용자 스토리 4

- 제목: 거래명세서 헤더 인쇄
- 내러티브
  - 배치 처리로 각 페이지 상단에 헤더를 인쇄한다.
  - 헤더는 고객 및 은행의 일반적인 정보를 보여준다.
- 인수 기준
  - 헤더는 고객 이름과 주소를 제외하고는 정적인 문자열이다.

</br >

### 사용자 스토리 5

- 제목: 계좌 요약 정보 인쇄하기
- 내러티브
  - 모든 계산이 완료된 이후에 배치 처리로 고객별 계좌 요약 정보를 인쇄한다.
  - 이 요약 정보는 고객 계좌의 개용를 보여준 뒤 해당 계좌의 총 금액을 구성하는 내역 목록을 보여준다.
- 인수 기준
  - 이 처리가 이뤄지면 고객별로 파일이 하나씩 생성된다.
  - 요약 정보는 한 줄로 시작한다.
    - BEGIN_DATE: 계좌 테이블의 마지막 거래명세서 작성일 바로 다음 날짜
    - END_DATE: 잡이 실행되는 날짜
    - 요약 제목 뒤에는 고객이 보유한 각 계좌에 해당 하는 헤더 행이 위치한다.
  - 계좌 헤더 다음 줄에는 계좌의 거래 목록이 표시된다.
  - 거래 목록 다음 줄에는 명세서 기간 내에 총 입금 금액과 총 출금 금액이 표시된다.
  - 마지막으로 계좌에 남아 있는 현재 잔액이 표시된다.
  - 고객이 가진 각 계좌의 계좌 헤더, 거래 목록, 잔액 정보 줄이 계속 반복된다.

</br >

## 배치 잡 설계

### 잡의 처리 흐름

1. 고객 데이터 가져오기
2. 거래 정보 데이터 가져오기
3. 현재 잔액 계산하기
4. 월별 고객 거래명세서 생성하기

</br >

### 고객 데이터 가져오기

- 특정 파일에 포함된 데이터를 읽어온다.
- ItemProcessor를 사용해 쓰기 처리할 때 데이터 유효성 검증 할 수 있음
- ItemWriter를 사용해 레코드 유형에 따라 가공하여 데이터 갱신

</br >

### 거래 정보 데이터 가져오기

- XML로 작성된 거레 데이터를 읽어온다.
- 읽온 데이터를 검증한 뒤 각 거래 레코드를 데이터베이스에 저장한다.

</br >

### 현재 잔액 계산하기

- 계좌 테이블의 잔액을 갱신해야 한다.
- 잔액은 온라인 계좌 서비스를 위해 미리 계산해 갱신하며, 갱신된 잔액은 거래명세서 생성 시에도 사용한다.
- 각 계좌 내 거래 코드를 순서대로 가져와서 해당 거래 레코드가 현재 잔액에 미치는 영향을 계산한다.
- 마지막으로 계좌 테이블의 잔액을 갱신한다.

</br >

### 월별 고객 거래명세서 생성하기

- 해당 스텝에서 고객의 거래명세서를 포함하는 인쇄 파일을 계좌당 하나씩 갱신하낟.
- ItemReader를 사용해 데이터베이스에서 고객 데이터를 읽어온다.
- ItemProcessor에 각 거래명세서 작성에 필요한 고객 데이터를 보낸다.
- ItemWriter는 최종적으로 완성된 데이터를 받아 고객 거래명세서를 생성한다.

</br >

## 데이터 모델

- Customer
  - 이 테이블의 레코드에는 고객별로 고객 이름 및 연락처 정보를 비롯한 모든 고객 정보가 포함된다.
- Account
  - 이 테이블의 모든 고객의 계좌 정보가 저장된다.
  - 계좌 정보는 계좌번화와 현재 잔액을 갖고 있다.
- CutomerAccount
  - 하나의 계좌에 많은 고객이 연관될 수 있고 한 명의 고객도 많은 계좌를 가질 수 있다.
  - 즉 해당 테이블을 통해 둘 사이의 관계를 조인시켜준다.
- Transaction
  - 계좌에서 발생한 모든 거래 정보가 저장된다.

